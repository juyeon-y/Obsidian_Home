## Problem with Thread / Request
### Traditional Thread / Request Programming
![[스크린샷 2024-04-08 오후 2.47.54.png]]
- 전통적 어플리케이션 프레임워크 : 앱/웹서버가 존재. 스레드 풀을 갖고 있다가 새 요청이 들어오면 해당 작업을 위한 스레드를 할당함. 
- 해당 접근법의 문제는 요청에 하나의 단일 스레드가 할당된다는 점.
- ex) 데이터베이스 호출 -> 얻은 결과로 계산 -> 다른 테이블이나 파일 시스템에 결과 write 한다고 가정 :
	- 데이터베이스 호출, 파일 시스템 등의 IO 작업은 시간이 많이 걸리며, 해당 시간동안 스레드는 막히고 대기 상태로 유지됨
	- 각 스레드에는 최대 1MB의 스택 메모리를 할당해야 함. 1GB RAM이 있고 400개의 요청이 동시 발생할 경우 400개의 스레드가 필요하며, 실제 작업에 필요한 메모리를 제외하고도이 스레드들만을 위해 400MB의 RAM이 사용되게 될 것임.

### Thread/Request In Microservices
![[스크린샷 2024-04-08 오후 4.45.04.png]]
- 현대 마이크로서비스 아키텍쳐 : 한 그룹의 마이크로서비스들이 서로 통신.
- ex) 

## IO Models
![[스크린샷 2023-12-22 오후 3.50.28.png]]

1. sync + blocking : 스레드들이 직접 요청 후 대기하면서 요청에 대한 답이 올 때까지 무한정 기다림.
2. async : 스레드가 직접 요청하는 대신 또 다른 스레드를 고용하여 요청을 대신 보내도록 하고, 그 동안 자신은 다른 일을 함. 요청을 필요로 하는 스레드는 비동기적으로 일처리를 하게 되지만, 요청을 대신 보내는 스레드는 1번 모델과 똑같은 sync + blocking 과정을 거치게 됨. 
3. non-blocking : = event driven model. low level 코딩을 필요로 하며 2번 모델보다 구현이 어려움. 스레드는 요청을 직접 보내고 이 요청이 처리되는 동안 다른 일을 하고 있고(not blocked), 요청에 대한 결과가 완료되면 OS가 스레드에게 이를 알려줌.
4. non-blocking + async :