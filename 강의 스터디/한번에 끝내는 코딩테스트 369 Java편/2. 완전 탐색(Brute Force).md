
### 완전 탐색이란
- 문제 해결 위해 확인해야 하는 `모든 경우를 전부 탐색`하는 방법
- 단순 for문 사용뿐만 아니라, 재귀함수, `백트래킹` 통해 문제 푸는 상황 포함
- 모든 코테 문제에서 `가장 기본적으로 접근해봐야하는 방식`
- 장점 : 부분점수 얻기 좋음
- 단점 : 전부 탐색하기 때문에 시간 복잡도 일반적으로 높음

### 코딩 테스트에 나오는 완전 탐색 종류
![](./attached_files/1.png)

### 완전 탐색 함수 정의
```java
// Recursive Function (재귀 함수)
// 만약 M개를 전부 고름 => 조건에 맞는 탐색을 한가지 성공한 것
// 아직 M개를 고르지 않음 => k번째부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 시도함
static void recFunc(int k) {}

public static void main(String[] args){
	input();
	// 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색
	recFunc(1);
	System.out.println(sb.toString());
}
```

### N개 중 `중복을 허용해서` M개를 `순서있게 나열하기`
- 문제 : [BOJ 15651 - N과M(3)](https://www.acmicpc.net/problem/15651)
- 자연수 N과 M이 주어졌을 때, 1부터 N까지 자연수 중에서 중복을 허용하여 M개를 고른 수열을 모두 구하는 문제
- N=4, M=3일 경우, 4X4X4 = 4^3 -> 시간복잡도는 `O(N^M)`
- 문제의 조건이 1<=M<=N<=7 이므로 7^7 = 약 82만. 1초에 1억번의 연산 가능하다고 했을 때 1초 안에 충분히 문제 풀 수 있음
- 표현해야하는 숫자가 총 M개 -> 공간복잡도는 `O(M)`
- 구현 스케치 :
```java
static int N, M;
static int[] selected;
// Recursive Function (재귀 함수)
// 만약 M개를 전부 고름 => 조건에 맞는 탐색을 한가지 성공한 것
// 아직 M개를 고르지 않음 => k번째부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 시도함
static void recFunc(int k) {
	if(k == M+1) { // 다 골랐다!
		// selected[1...M] 배열이 새롭게 탐색된 결과
	} else {
		// 1~N까지를 k번 원소로 한 번씩 정하고,
		// 매번 k+1번부터 M번 원소로 재귀호출 해주기
	}
}
```
- 실제 구현 : 
```java
import java.io.*;
import java.util.*;

public class Main {
	static StringBuilder sb = new StringBuilder();
	static int N, M;
	static int[] selected;

	static void input() {
		FastReader reader = new FastReader();
		N = reader.nextInt();
		M = reader.nextInt();
		selected = new int[M+1];
	}

	// Recursive Function (재귀 함수)
	// 만약 M 개를 전부 고름 => 조건에 맞는 탐색을 한 가지 성공한 것!
	// 아직 M 개를 고르지 않음 => k 번째부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 시도한다
	static void recFunc(int k) {
		if(k == M+1) { // 다 골랐다!
			// selected[1...M] 배열이 새롭게 탐색된 결과
			for(int i=1; i<=M; i++){
				sb.append(selected[i]).append(' ');
			}
			sb.append('\n');
		} else {
			for(int c=1; c<=N; c++){
				// k번째에 c(candidate)가 올 수 있으면
				selected[k] = c;
				// k+1번부터 M번까지 잘 채워주는 함수를 호출해준다.
				recFunc(k+1);
			}
		}
	}

  

public static void main(String[] args) {

input();

  

// 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색

recFunc(1);

  

System.out.println(sb.toString());

}

  

static class FastReader {

BufferedReader br;

StringTokenizer st;

  

public FastReader() {

br = new BufferedReader(new InputStreamReader(System.in));

}

  

String next() {

while(st == null || !st.hasMoreTokens()) {

try {

st = new StringTokenizer(br.readLine());

} catch(IOException e) {

e.printStackTrace();

}

}

return st.nextToken();

}

  

int nextInt() {

return Integer.parseInt(next());

}

  

long nextLong() {

return Long.parseLong(next());

}

  

double nextDouble() {

return Double.parseDouble(next());

}

  

String nextLine() {

String str = "";

try {

str = br.readLine();

} catch(IOException e) {

e.printStackTrace();

}

return str;

}

}

}
``` 


<br/>

>##### 📚 참고 : StringTokenizer
>- 문자열을 여러 개의 토큰으로 분리하는 클래스
>```
>// 1) 띄어쓰기 기준 문자열 분리
>StringTokenizer st = new StringTokenizer(문자열);
>// 2) 구분자 기준 문자열 분리
>StringTokenizer st = new StringTokenizer(문자열, 구분자);
>// 3) 구분자 기준 분리 시, 구분자도 토큰으로 포함 X (default)
>StringTokenizer st = new StringTokenizer(문자열, 구분자, false);
>// 4) 구분자 기준 분리 시, 구분자도 토큰으로 포함 O
>StringTokenizer st = new StringTokenizer(문자열, 구분자, true);
>
>// 남아있는 토큰이 있을 경우, 다음 토큰 출력
>while (st.hasMoreTokens()) {
>	System.out.println(st.nextToken());
>}
>``` 
