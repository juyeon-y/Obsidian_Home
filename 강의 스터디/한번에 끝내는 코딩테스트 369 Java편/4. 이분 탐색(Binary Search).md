
### (수열에서의) 탐색이란
- 수열과 탐색 대상 X가 주어졌을 때,
  ex) X = 63, {72, 19, 38, 58, 10, 92, 18, 11, 87}
  아래와 같은 질문을 던지는 것을 탐색이라고 함 :
	1. X가 수열에 존재하는지?
	2. X[이하, 미만, 이상, 초과]인 원소는 몇 개가 있는지?
	3. X랑 가장 가까운 원소는 무엇인지? 

- 모든 원소를 하나씩 보면서 확인하면 되기 때문에, 아무 수열 주어졌을 경우 위 질문들에 대해 모두 시간복잡도 $O(N)$ 만에 대답 가능

- 만약, 아무 수열이 주어진 것이 아니라 정렬된 수열이 주어진다면?
- 정렬된 수열과 탐색 대상 X가 주어졌을 때, 더 빠르게 방금했던 질문들에 대한 대답을 할 수 있는 방법 => `이분 탐색`

### 이분 탐색(Binary Search)
- `정렬이 보장되는 배열`에서 기준 X를 가지고 범위를 `이분` 하면서 탐색하는 방법
- 아래와 같은 질문들에 대해 이분 탐색 사용 시, 시간복잡도 $O(logN)$으로 탐색 가능 :
	1. X가 수열에 존재하는지?
	2. X[이하, 미만, 이상, 초과]인 원소는 몇 개가 있는지?
	3. X랑 가장 가까운 원소는 무엇인지?

- 참고) 1번 2번과 달리, 3번은 추가로 "각 원소마다, 그 원소와 가장 가까운/비슷한 원소는 해당 원소의 양 옆에 있는 원소 중에 존재한다" 는 정렬의 특성 이용해 풀어야 함 ([BOJ 2470 - 두 용액](https://www.acmicpc.net/problem/2470))

### 이분 탐색 이해를 위한 정렬의 특성
- 오름차순 정렬이 된 배열의 특성
  ex) X= 63, {10, 11, 18, 19, 38, 58, 72, 87, 92}
	1. 임의의 M번 인덱스에 있는 A[M]이 X보다 크다면, A[M...N]은 전부 X보다 크다
	2. 임의의 M번 인덱스에 있는 A[M]이 X보다 작다면, A[1..M]은 전부 X보다 작다

- 즉, 한 번의 비교로 여러가지 비교의 결과를 한 번에 알 수 있다는 특성이 있음
- 위의 성질은 오름차순 정렬이기 때문에 생기는 성질이며, 정렬이 아니라면 불가능

### 이분 탐색 예시
- 사용할 변수 :
	- `arr` : 탐색할 대상인 배열
	- `L` : 탐색할 가치가 있는 범위의 `왼쪽 끝 인덱스`
	- `R` : 탐색할 가치가 있는 범위의 `오른쪽 끝 인덱스`
	- `M` : 범위를 이분한 `중간 인덱스` (= (L+R) / 2)
	- `result` : 탐색이 진행되면서 탐색 목표의 인덱스를 기록할 변수 (나중에 정답으로 사용)

- 예시 : 
	- X = 63
	- 탐색 목표 : X 이하의 원소 중에 가장 오른쪽에 있는 원소

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 10  | 11  | 18  | 19  | 38  | 58  | 72  | 87  | 92  |

| 순서  | L         | R         | M (= (L+R)/2) | arr[M]과 X 비교   | result | 비고                                               |
| --- | --------- | --------- | ------------- | -------------- | ------ | ------------------------------------------------ |
| 초기값 | 1         | 9         |               |                | 0      |                                                  |
|     |           |           | 5             | arr[5]=38 <= X |        |                                                  |
| 1   | 6 (= M+1) | 9         |               |                | 5      | - L에 M+1 대입                                      |
|     |           |           | 7             | arr[7]=72 > X  |        |                                                  |
| 2   | 6         | 6 (= M-1) |               |                | 5      | - R에 M-1 대입                                      |
|     |           |           | 6             | arr[6]=58 <= X |        |                                                  |
|     | 7 (= M+1) | 6         |               |                | 6      | - L에 M+1 대입<br>- L>R이므로<br>탐색할 가치가 있는<br>구간이 없다! |

- result = 6 이므로,
	- arr[6]은 X 이하 중 제일 큰 값이고
	- arr[7]은 X보다 큰 값일 것
	- 또한 X 이하의 숫자가 6개인 것도 알 수 있음

### 이분 탐색의 시간 복잡도
- arr[M]과 X를 한 번 비교할 때마다 [L, R] 구간이 절반씩 좁아짐
- 구간의 길이가 N -> $\dfrac {N}{2}$ -> $\dfrac {N}{4}$ -> ... -> 1 의 순서로 구간이 점점 좁아짐
- 즉, "총 비교 횟수"는 "구간의 변화 횟수"인 $logN$ 번. 따라서 (배열이 정렬되어있다는 가정하에) 시간복잡도 $O(logN)$ 만에 원하는 값을 탐색하게 됨
- 만약 N개의 원소를 갖는 배열이 있고 X 이하인 원소의 갯수를 찾는다고 할 때, N = 10만, X = 63이라면,
	- 일일이 다 찾을 경우엔 10만 번의 비교를 해야 하지만,
	- 이분 탐색할 경우엔 log 100,000 = 16.xx 이므로 약 16번만 비교하면 답 찾기 가능

### 이분 탐색에서 자주하는 실수
1. 입력된 배열에 바로 이분 탐색을 하는데, `정렬을 하지 않은` 경우
2. L, R, M, result 변수의 정의를 헷갈려서 부등호 등을 잘못 쓰는 경우
3. L, R 범위를 잘못 설정하거나 result의 초기값을 잘못 설정하는 경우

### 예시 문제
- [BOJ 7795 - 먹을 것인가 먹힐 것인가](https://www.acmicpc.net/problem/7795)
- 정답의 최대치 체크 : 모든 쌍이 정답인 경우, N * M = 20000 * 20000 = 4억 => Integer로 커버 가능!
- 시간복잡도 : 
	- 완전탐색 : 
		- 모든 A에 대해 B에서 A[i] 미만 원소들 찾을 경우, 시간복잡도는 $O(NM)$. 최악의 경우 20000 * 20000 = 4억 번 연산이 필요
		  => 4초가 걸리게 되며 문제의 시간제한(1초)에 걸림!
	- 이분탐색 : 
		- B를 정렬하고 이분탐색을 사용할 경우, 
		- 1) B 배열 정렬 한 번 => $O(MlogM)$
		- 2) B에서 A[i] 미만 원소들 한 번 찾을 때마다 $O(logM)$이 걸리게 됨. 모든 A의 원소마다, B 배열에 대해 이분 탐색 필요하므로
		  => $O(NlogM)$
		- 따라서 총 시간 복잡도는 $O((M+N)logM)$. 최대 40000 * log 20000 = 약 560000 번의 연산이 이루어지므로 1초 안에 연산 가능.

- 구현 : 
``` java
import java.io.*;
import java.util.*;

public class Main {

    static FastReader reader = new FastReader();
    static int N, M;
    static int[] A, B;

    static void input() {
        N = reader.nextInt();
        M = reader.nextInt();
        A = new int[N+1];
        B = new int[M+1];
        for(int i=1; i<=N; i++) {
            A[i] = reader.nextInt();
        }
        for(int i=1; i<=M; i++) {
            B[i] = reader.nextInt();
        }
    }

    static int binarySearch(int[] arr, int L, int R, int target) {
        //arr[L...R]에서 target 미만인 수 중 가장 오른쪽 인덱스를 리턴하는 함수
        // 변수 이름을 목표대상인 X만 target로 수정하였음
        int result = 0;
        while(L <= R) {
            int M = (L+R)/2;
            if(arr[M] < target) {
                result = M;
                L = M+1;
            } else {
                R = M-1;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int T = reader.nextInt();
        for(int tc = 0; tc<T; tc++) {
            input();
            Arrays.sort(B, 1, M+1);
            int answer = 0;
            for(int i=1; i<=N; i++) {
                answer += binarySearch(B, 1, M, A[i]);
            }
            System.out.println(answer);
        }
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while(st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
```

<br/>

>##### 📚 참고 : Arrays 클래스의 sort 메서드 사용한 부분 정렬
>``` java
>// 메서드 원형 
>static void sort(Object[] a, int fromIndex, int toIndex)
>// 사용법
>Arrays.sort(arr, fromIndex, toIndex);
>// 설명
>- 범위를 지정하여 객체를 정렬하고 싶을 때는 fromIndex, toIndex 인자로 넘겨 정렬 가능
>- 주어진 배열 arr의 fromIndex 원소부터 "toIndex - 1"까지의 원소를 정렬함
>- toIndex로는 배열하고자 하는 범위의 마지막 원소의 인덱스에 1을 더한 값을 넘겨야 한다는 점 주의!
>``` 

<br/>

### 연습 문제
- [BOJ 1920 - 수 찾기](https://www.acmicpc.net/problem/1920)
- [BOJ 1764 - 듣보잡](https://www.acmicpc.net/problem/1764)
- [BOJ 3273 - 두 수의 합](https://www.acmicpc.net/problem/3273)
- [BOJ 10816 - 숫자 카드2](https://www.acmicpc.net/problem/10816)
- [BOJ 2470 - 두 용액](https://www.acmicpc.net/problem/2470)

### 이분탐색 응용 - 매개 변수 탐색 (Parametric Search)
- 매개 변수 탐색은 이분 탐색의 아이디어를 사용함
- ex1) 배열이 0과 1만 존재하며 오름차순인 건 보장되지만, 전체 배열은 모른다. 특정 인덱스의 값을 O(T)에 계산 가능할 때, 여기서 0과 1의 경계를 찾아야 한다면?
	- 전체 배열 차례대로 확인해가며 인덱스 값 계산 -> $O(T * N)$
	- 이분탐색으로 확인해가며 인덱스 값 계산 -> $O(T * logN)$ => 훨씬 빠름!
- ex2) A가 1~1000 사이의 어떤 자연수를 선택. B는 A에게 "생각한 숫자가 X이상이야?" 라는 질문 가능. A는 맞으면 Yes, 아니면 No로 대답하며 질문에 걸리는 시간은 O(T). 최소 횟수로 질문하려면?
	- 마지막 Yes인 대답이 정답
	- 1부터 1000까지 차례대로 확인해가며 질문 -> $O(T * 1000)$
	- [L=1, R=1000]에서 이분 탐색하며 질문 -> $O(T * log1000) = O(T * 10)$ => 훨씬 빠름!

### 매개 변수 탐색의 핵심 과정
1. `정답을 "매개 변수(Parameter)"로` 만들고 `Yes/No 문제(결정 문제)`로 바꿔 보기
2. 모든 값에 대해서 Yes/No 를 채웠다고 생각했을 때, `정렬된 상태인가?` (ex. $Y, Y, Y, ...|N, N, N, ...$ 혹은 $N, N, N, ...|Y, Y, Y, ...$)
3. Yes/No 결정하는 문제를 `풀기!`

### 매개 변수 탐색에서 자주 하는 실수
1. 매개 변수에 대한 결정이 `정렬된 꼴`(ex. $Y, Y, Y, ...|N, N, N, ...$ 혹은 $N, N, N, ...|Y, Y, Y, ...$)`이 아닌데` 이분 탐색하는 경우
   (-> 매개 변수 탐색이 아닌 다른 방법으로 풀어야)
2. L, R, M, result 변수의 정의를 헷갈려서 부등호 등을 잘못 쓰는 경우
3. L, R 범위를 잘못 설정하거나 result의 초기값을 잘못 설정하는 경우

### 매개 변수 탐색 키워드
- 다음과 같은 키워드가 나오면 매개 변수 탐색(Parametric Search) 접근을 시도해볼 가치가 있음
	- ~~ 의 `최댓값`을 구하시오
	- ~~ 의 `최솟값`을 구하시오

### 예시 문제 1
- [BOJ 2805 - 나무 자르기](https://www.acmicpc.net/problem/2805)
- 원래 문제 : `원하는 길이 M만큼을 얻을 수 있는` 최대 `높이`는 얼마?
- 뒤집은 문제 : 어떤 `높이`로 잘랐을 때, `원하는 길이 M만큼을 얻을 수 있는가?` -> Yes/No
- 구현 : 
``` java
import java.io.*;
import java.util.*;

public class Main {

    // 1 <= N <= 백만, 1 <= M <= 20억, 0 <= 나무 높이(X) <= 십억
    // 최대최소치 : 답 높이의 최댓값은 십억, 나무 높이 합의 최댓값은 1000000 * 1000000000 -> long!!
    // 시간복잡도 : 나무 절단하여 몇미터 가져갈 수 있는지 확인하는데 O(N) 소요, 자를 높이 이분탐색하는데 O(log 나무 최대 높이) 소요 -> 시간복잡도 O(NlogX). 최대로는 백만 * log 십억 = 2900만

    static int N, M, maxHeight = 0;
    static int[] arr;

    static void input() {
        FastReader reader = new FastReader();
        N = reader.nextInt();
        M = reader.nextInt();
        arr = new int[N];
        for(int i=0; i<N; i++) {
            arr[i] = reader.nextInt();
            maxHeight = Math.max(arr[i], maxHeight);
        }
    }

    static boolean determination(int x) {
        long sum = 0;
        for(int i=0; i<N; i++) {
            if(arr[i] > x) {
                sum += arr[i] - x;
            }
        }
        return sum >= M;
    }

    static int binarySearch(int L, int R) {
        int result = 0;
        while(L <= R) {
            int M = (L+R) / 2;
            boolean isYes = determination(M);
            if(isYes) {
                result = M;
                L = M + 1;
            } else {
                R = M - 1;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        // 1) 답을 파라미터로 한 결정 문제 만들기 : 높이를 X로 설정하면 M미터 이상 가져갈 수 있나? -> Yes/No
        // 2) 정렬 상태인지 확인 : 높이 [0 ~ max] 일 때 결정 문제의 답은 Y, Y, Y, ... | N, N, N, ...의 형태를 띄게 됨. 따라서 정렬 상태!
        // 가장 마지막 Yes를 찾아야.
        input();
        System.out.println(binarySearch(0, maxHeight));
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while(st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
```

### 예시 문제2
- [BOJ 2110 - 공유기 설치](https://www.acmicpc.net/problem/2110)
- 

### 연습 문제
- [BOJ 1654 - 랜선 자르기](https://www.acmicpc.net/problem/1654)
- [BOJ 2512 - 예산](https://www.acmicpc.net/problem/2512)
- [BOJ 2343 - 기타 레슨](https://www.acmicpc.net/problem/2343)
- [BOJ 6236 - 용돈 관리](https://www.acmicpc.net/problem/6236)
- [BOJ 13702 - 이상한 술집](https://www.acmicpc.net/problem/13702)
- [BOJ 17266- 어두운 굴다리](https://www.acmicpc.net/problem/17266)

- [BOJ 1300 - K 번째 수](https://www.acmicpc.net/problem/1300) (고난이도)
- [BOJ 1637 - 날카로운 눈](https://www.acmicpc.net/problem/1637) (고난이도)