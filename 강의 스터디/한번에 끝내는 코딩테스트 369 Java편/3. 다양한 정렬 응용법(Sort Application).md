
### 정렬이란
- 어떤 자료들에 대해서 특정 기준에 맞게 자료들을 정렬하는 것

### 정렬에 대해 기본적으로 알아야 할 사항
#### 1) Java Comparable 이용한 정렬 구현 방법
```java
static class Element implements Comparable<Element> {

	public int num, idx;

	@Override
	public int compareTo(Element other) {
		return this.num - other.num; // num 기준 오름차순
	}
	// return 음수 : 내가 먼저
	// return 양수 : 쟤(other)가 먼저
	// return 0   : 나랑 쟤(other)랑 동급
}
```

#### 2) 시간복잡도는 약 O($NlogN$)
- N개의 원소를 정렬하는 것은 O($NlogN$) 만큼의 시간 복잡도를 가짐
	- 만약 N = 10만 이라고 하면, log 100000 = 16.xx 이기 때문에 10만 개의 원소를 정렬하는 것은 대략 160만 번의 연산만 필요. 즉, 1초에 1억 번의 연산 가능하다고 했을 때 1초 안에 연산 가능
	- 위와 같이 N이 커도 충분히 커버 가능하기 때문에 문제에서 정렬하라는 얘기 하지 않더라도 한 번쯤 정렬을 고민해보는 것이 좋음
- 자바에서 제공하는 `Arrays.sort(arr)`는 내부구현이 Primitive 원소를 정렬할 때와 Object 원소를 정렬할 때가 다름

| Arrays.sort(arr) | Primitive 원소(ex. int) 정렬 시 | Object 원소 (ex. Integer) 정렬 시                  |
| ---------------- | -------------------------- | --------------------------------------------- |
| 내부구현             | `Dual-Pivot Quick Sort`    | `Tim Sort` (Selection Sort와 Merge Sort를 합친 것) |
| 최선 시간복잡도         | O($N$)                     | O($N$)                                        |
| 최악 시간복잡도         | O($N^2$)                   | O($NlogN$)                                    |
| 평균 시간복잡도         | O($NlogN$)                 | O($NlogN$)                                    |

#### 3) In-place / Stable 여부 알아야 함
- 정렬 알고리즘이 `In-place(제자리)` 한가?
	=> 정렬하는 과정에서 N에 비해 충분히 무시할 만한 개수의 메모리만큼만 추가적으로 사용하는가?
- 정렬 알고리즘이 `Stable(안정)` 한가?
	=> 동등한 위상의 원소들의 순서 관계가 보존되는가?

| Arrays.sort(arr)     | Primitive 원소(ex. int) 정렬 시 | Object 원소 (ex. Integer) 정렬 시 |
| -------------------- | -------------------------- | ---------------------------- |
| 내부구현                 | Dual-Pivot Quick Sort      | Tim Sort                     |
| In-place<br>(제자리 정렬) | `In-place`                 | Not In-place                 |
| Stable<br>(안정 정렬)    | Not Stable                 | `Stable`                     |

#### 결론적으로 알아야 할 것
- 내가 정렬을 사용한다
	=> 시간복잡도는 O($NlogN$)이 될 것이다
- Object 원소를 Arrays.sort(arr) 사용해 정렬할 것이다
	=> Tim Sort가 따라올 것이므로, Stable 하다
- Primitive 원소를 Arrays.sort(arr) 사용해 정렬할 것이다
	=> Dual-Pivot Quick Sort가 따라올 것이므로, In-place 하다 

### 문제 풀 때 이용 가능한 정렬의 특성
1. 같은 정보들은 정렬 후에 무조건 인접하게 된다
2. 각 원소마다, 그 원소와 가장 가까운 원소는 자신의 양 옆 중에 있을 수 밖에 없다
3. 정렬만 해도 문제가 쉽게 풀리는 경우가 상당히 많음!


