
### 정렬이란
- 어떤 자료들에 대해서 특정 기준에 맞게 자료들을 정렬하는 것

### 정렬에 대해 기본적으로 알아야 할 사항
#### 1) Java Comparable 이용한 정렬 구현 방법
```java
static class Element implements Comparable<Element> {

	public int num, idx;

	@Override
	public int compareTo(Element other) {
		return this.num - other.num; // num 기준 오름차순
	}
	// return 음수 : 내가 먼저
	// return 양수 : 쟤(other)가 먼저
	// return 0   : 나랑 쟤(other)랑 동급
}
```

#### 2) 시간복잡도는 약 O($NlogN$)
- N개의 원소를 정렬하는 것은 O($NlogN$) 만큼의 시간 복잡도를 가짐
	- 만약 N = 10만 이라고 하면, $log_2 100000$ = 16.xx 이기 때문에 10만 개의 원소를 정렬하는 것은 100,000 * log 100,000 = 약 160만 번의 연산만 필요. 즉, 1초에 1억 번의 연산 가능하다고 했을 때 1초 안에 연산 가능
	- 위와 같이 N이 커도 충분히 커버 가능하기 때문에 문제에서 정렬하라는 얘기 하지 않더라도 한 번쯤 정렬을 고민해보는 것이 좋음
- 자바에서 제공하는 `Arrays.sort(arr)`는 내부구현이 Primitive 원소를 정렬할 때와 Object 원소를 정렬할 때가 다름

| Arrays.sort(arr) | Primitive 원소(ex. int) 정렬 시 | Object 원소 (ex. Integer) 정렬 시                  |
| ---------------- | -------------------------- | --------------------------------------------- |
| 내부구현             | `Dual-Pivot Quick Sort`    | `Tim Sort` (Selection Sort와 Merge Sort를 합친 것) |
| 최선 시간복잡도         | O($N$)                     | O($N$)                                        |
| 최악 시간복잡도         | O($N^2$)                   | O($NlogN$)                                    |
| 평균 시간복잡도         | O($NlogN$)                 | O($NlogN$)                                    |

#### 3) In-place / Stable 여부 알아야 함
- 정렬 알고리즘이 `In-place(제자리)` 한가?
	=> 정렬하는 과정에서 N에 비해 충분히 무시할 만한 개수의 메모리만큼만 추가적으로 사용하는가?
- 정렬 알고리즘이 `Stable(안정)` 한가?
	=> 동등한 위상의 원소들의 순서 관계가 보존되는가?

| Arrays.sort(arr)     | Primitive 원소(ex. int) 정렬 시 | Object 원소 (ex. Integer) 정렬 시 |
| -------------------- | -------------------------- | ---------------------------- |
| 내부구현                 | Dual-Pivot Quick Sort      | Tim Sort                     |
| In-place<br>(제자리 정렬) | `In-place`                 | Not In-place                 |
| Stable<br>(안정 정렬)    | Not Stable                 | `Stable`                     |

#### 결론적으로 알아야 할 것
- 내가 정렬을 사용한다
	=> 시간복잡도는 O($NlogN$)이 될 것이다
- Object 원소를 Arrays.sort(arr) 사용해 정렬할 것이다
	=> Tim Sort가 따라올 것이므로, Stable 하다
- Primitive 원소를 Arrays.sort(arr) 사용해 정렬할 것이다
	=> Dual-Pivot Quick Sort가 따라올 것이므로, In-place 하다 

### 문제 풀 때 이용 가능한 정렬의 특성
1. `같은 정보`들은 정렬 후에 무조건 `인접`하게 된다. (ex. 1 **3 3 3** 4 6)
2. 각 원소마다, 그 원소와 `가장 가까운/비슷한 원소`는 해당 원소의 `양 옆에 있는 원소` 중에 존재한다. (전체를 다 볼 필요 없이 양 옆에 있는 원소 중 뭐가 더 가까운지만 보면 됨)
3. 정렬만 해도 문제가 쉽게 풀리는 경우가 상당히 많음!

<br/>

>##### 📚 참고 : 정렬 알고리즘
>https://code-lab1.tistory.com/24
>https://maramarathon.tistory.com/49
>https://velog.io/@sisofiy626/Algorithm-%EC%A0%95%EB%A0%AC-%ED%80%B5-%EC%A0%95%EB%A0%ACQuick-Sort
>https://nx006.tistory.com/67
>https://cdragon.tistory.com/entry/Algorithm-Quick-Sort%ED%80%B5-%EC%A0%95%EB%A0%AC
>https://splendidlolli.tistory.com/366
>https://bblackscene21.tistory.com/8

|                      | 선택 정렬<br>(Selection Sort) | 버블 정렬<br>(Bubble Sort) | 삽입 정렬<br>(Insertion Sort) | 합병 정렬<br>(Merge Sort) | 퀵정렬<br>(Quick Sort) |
| -------------------- | ------------------------- | ---------------------- | ------------------------- | --------------------- | ------------------- |
| 공간복잡도                | $O(1)$                    | $O(1)$                 | $O(1)$                    | $O(N)$                | $O(logN)$           |
| 평균(Average)<br>시간복잡도 | $O(N^2)$                  | $O(N^2)$               | $O(N^2)$                  | $O(NlogN)$            | $O(NlogN)$          |
| 최악(Worst)<br>시간복잡도   | $O(N^2)$                  | $O(N^2)$               | $O(N^2)$                  | $O(NlogN)$            | $O(N^2)$            |
| 최선(Best)<br>시간복잡도    | $O(N^2)$                  | $O(N^2)$               | $O(N)$                    | $O(NlogN)$            | $O(NlogN)$          |
| In-place<br>(제자리 정렬) | In-place                  | In-place               | In-place                  | Not In-place          | In-place            |
| Stable<br>(안정 정렬)    | Not Stable                | Stable                 | Stable                    | Stable                | Not Stable          |

<br/>

### 예시 문제
- [BOJ 10825 - 국영수](https://www.acmicpc.net/problem/10825)
- 시간복잡도 : 정렬만하면 되니까 O($NlogN$)
- 1 ≤ N ≤ 100,000 이므로, 최대 100,000 * log 100,000 = 약 160만. 1초에 1억 번의 연산 가능하다고 했을 때 1초 안에 연산 가능

- 구현 :
``` java
import java.io.*;
import java.util.*;

public class Main {

    static StringBuilder sb = new StringBuilder();
    static int N;
    static Student[] studentArr;

    static class Student implements Comparable<Student>{

        String name;
        int korScore, engScore, mathScore;

        public Student(String name, int korScore, int engScore, int mathScore) {
            this.name = name;
            this.korScore = korScore;
            this.engScore = engScore;
            this.mathScore = mathScore;
        }

        @Override
        public int compareTo(Student other) {
            if(this.korScore != other.korScore) {
                return other.korScore - this.korScore;
            } else if(this.engScore != other.engScore) {
                return this.engScore - other.engScore;
            } else if(this.mathScore != other.mathScore) {
                return other.mathScore - this.mathScore;
            } else {
                return this.name.compareTo(other.name);
            }
        }
    }

    static void input() {
        FastReader reader = new FastReader();
        N = reader.nextInt();
        studentArr = new Student[N];
        for(int i=0; i<N; i++) {
            studentArr[i] = new Student(reader.next(), reader.nextInt(), reader.nextInt(),reader.nextInt());
        }
    }

    public static void main(String[] args) {
        input();

        Arrays.sort(studentArr);
        for(int i=0; i<N; i++) {
            sb.append(studentArr[i].name).append('\n');
        }

        System.out.println(sb.toString());
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while(st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
```

<br/>

>##### 📚 참고 : String 클래스의 compareTo 메서드
>``` java
>// 메서드 원형 
>public int compareTo(String anotherString)
>// 사용법
>str.compareTo(anotherStr);
>// 리턴값
>1) str이 anotherStr보다 사전순으로 앞에 오는 경우, 음의 정수 리턴
>2) str이 anotherStr보다 사전순으로 나중에 오는 경우, 양의 정수 리턴
>3) 두 문자열이 같을 경우, 0 리턴
>``` 

<br/>

### 응용문제
- [BOJ 1015 - 수열 정렬](https://www.acmicpc.net/problem/1015)