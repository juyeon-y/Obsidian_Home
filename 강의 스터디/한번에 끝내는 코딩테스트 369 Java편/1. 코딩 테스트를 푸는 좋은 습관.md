
<br/>

### 코딩 테스트를 풀 때 가져야 할 좋은 습관
#### 1. 문제를 올바른 `순서`로 풀기
1) 읽기 (`시간/메모리 제한 확인`, `문제 전체 꼼꼼히 읽기`)
2) 이해하기 (`제공되는 정보(변수들) 정리`, `예제 데이터 이해`)
3) 파악하기 (`가능한 최대/최소 정답에 맞는 데이터 직접 생성`, `키워드가 되는 단어 체크`)

#### 2. `시간/공간복잡도` 계산하기
| 알고리즘                  | 시간복잡도                        | 공간복잡도    |
| --------------------- | ---------------------------- | -------- |
| BFS & DFS (w/ 인접 리스트) | $O(V+E)$                     | $O(V+E)$ |
| Dijkstra              | $O(ElogE)$ or $O(ElogV)$     | $O(V+E)$ |
| Quick Sort            | 평균 $O(NlogN)$<br>최악 $O(N^2)$ | $O(V)$   |
| Binary Search         | $O(NlogN)$                   | $O(N)$   |
- 시간/공간복잡도가 필요한 이유 -> 시간을 아끼기 위해서. 코드를 짤 가치가 있나? (시간 제한 걸린다면 짤 가치 X)
	- ex) 이중포문 때문에 N제곱의 시간복잡도를 갖는 알고리즘이 있고 & N이 최대 10만일 경우 -> 시간복잡도는 대략 100억에 육박. 컴퓨터는 대략 1초에 1억번 연산 가능하기 때문에 해당 알고리즘으로 코드 짤 경우 100초가 걸리게 됨

#### 3. 코드를 효율적으로 잘 `함수화`해서 구현
- 여러 군데에서 필요한 알고리즘을 함수화하여 반복 호출
- 구현할 양 줄어 시간 절약 & 실수 줄일 수 있음

#### 4. `부분 점수` 챙기기
- 점수 싸움이므로 부분 점수 꼭 챙기기

#### 결론
1) 정답의 최대/최소치 확인 (ex. int : -21억 ~ 21억)
2) 시간/공간복잡도 확인 (대략 1초에 1억번 연산)
3) 잘 구현