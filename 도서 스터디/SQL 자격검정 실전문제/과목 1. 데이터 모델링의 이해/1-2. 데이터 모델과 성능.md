
### 1. 정규화
#### 정규화란
- `정규화(Normalization)` : 
	- 정규화는 `논리 데이터 모델 상세화 과정` 의 대표적 활동
	- `논리 데이터 모델의 일관성을 확보하고 중복을 제거`하여 속성들이 가장 적절한 엔터티에 배치되도록 함으로써 보다 더 신뢰성 있는 데이터구조를 얻는 데 목적이 있음. (개념 데이터 모델의 일관성 확보 x)
- `정규형(NF; Normal Form)` : 정규화로 도출된 데이터 모델이 갖춰야 할 특성
	1) `제1정규형` : `모든 속성은 반드시 하나의 값(원자값)`을 가져야 함
	2) `제2정규형` : 엔터티의 `일반속성은 주식별자 전체에 종속`이어야 함
	3) `제3정규형` : 엔터티의 `일반속성 간에는 서로 종속적이지 않아야` 함
- 결정자 : 속성 A가 속성 B를 결정한다는 것은, A의 값이 B의 값을 유일하게 결정하는 경우를 말함
- `함수적 종속성(FD; Functional Dependency)` : 결정자와 종속자의 관계. 결정자의 값으로 종속자의 값을 알 수 있음

#### 정규화 이론
1) `1차 정규화` : 
	- `모든 속성이 하나의 값만` 가지도록 하는 것
	- 속성의 원자성 확보 및 중복속성에 대한 분리
	- 로우 단위의 중복, 칼럼 단위의 중복 모두 1차 정규화의 대상
2) `2차 정규화` : 
	- `부분 함수 종속성` 제거
		![](./attached_files/3.png)
	- `일부 기본키에만 종속된 속성`을 분리
	- 기본키가 하나의 칼럼일 땐 생략 가능
3) `3차 정규화` : 
	- `이행 함수 종속성` 제거
		![](./attached_files/4.png)
	- `서로 종속관계가 있는 일반속성`을 분리
	- 주식별자와 관련성이 가장 낮음
4) `보이스코드 정규화(BCNF; Boyce-Codd Normal Form)` : 
	- 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 `모든 결정자가 후보키가 되도록` 하는 것
	- ex) Student, Course, Professor가 속성으로 있는 테이블 가정 : 
		- (학생번호, 과목)이 기본키로 지도교수를 알 수 있는 테이블
		- 함수적 종속성 : "Student, Course -> Professor" (각 학생은 각 강좌에 대해 하나의 교수만 가질 수 있음), "Professor -> Course" (교수는 특정 강좌를 가르침)
		- 이 종속성에서 교수(Professor)는 결정자지만 후보 키가 아님. Professor는 테이블의 행을 고유하게 식별할 수 없기 때문
		- “Professor -> Course" 함수적 종속성이 BCNF를 위반
5) `4차 정규화` : 
	- `다치 종속` 제거
	- 다치 종속 : 
		- 같은 테이블 내의 독립적인 두 개 이상의 컬럼이 또 다른 컬럼에 종속되는 것
		- A → B 인 의존성에서 단일 값 A와 다중 값 B가 존재한다면 다치 종속
		- 이중 화살표(double arrow) ↠ 로 표기
		- 다치 종속은 최소 2개의 컬럼이 다른 컬럼에 종속되어야 하기 때문에 최소 3개의 컬럼이 필요
	- ex) Student, Course, Hobby가 속성으로 있는 테이블 가정 : 
		- 학생(Student)이 여러 강좌(Course)를 수강하고, 동시에 여러 취미(Hobby)를 가질 수 있음
		- Student -> Course와 Student -> Hobby 두가지 의존성을 가지므로 다치 종속
6) `5차 정규화` : 
	- `조인 종속` 제거
	- 조인 종속 : 하나의 릴레이션을 여러개의 릴레이션으로 분해하였다가, 다시 조인했을 때 데이터 손실이 없고 필요없는 데이터가 생기는 것
	- 5차 정규화는 조인에 의한 이상현상을 제거하여 정규화 수행

#### 정규화와 성능
- 정규화로 인한 성능 향상 : 
	- 데이터를 `입력/수정/삭제할 때는 일반적으로 처리 성능이 향상`됨
	- `중복 속성 제거`하여 용량 최소화 가능
	- 유연성 증가 : High Cohesion & Loose Coupling 원칙에 충실해짐
	- 재활용 가능성 증가 : 개념이 세분화됨
- 정규화로 인한 성능 저하 : 
	- 데이터 조회 시엔 처리 조건에 따라 `조회 성능 저하`가 발생할 수도 있음
	- 데이터 조회 시 조인을 유발하여 CPU와 메모리를 많이 사용하게 됨
	- 이 때문에 성능을 위해 데이터 중복을 허용하는 `반정규화` 고려하기도. 하지만 `반정규화만이 조회 성능을 항상 향상시키는 것은 아니며` 때로는 정규화에 의해 성능이 향상될 수도 있음

### 2. 관계와 조인의 이해
- `조인(Join)`이란 `식별자를 상속하고, 상속된 속성을 매핑키로 활용하여 데이터를 결합하는 것` 의미
- 부모의 식별자를 자식의 식별자에 포함하면 `식별관계`, 부모의 식별자를 자식의 일반속성으로 상속하면 `비식별관계`
- 관계(Relationship)를 맺는다는 것은 식별자를 상속시키고 해당 식별자를 매핑키로 활용해 데이터를 결합해 보겠다는 것 의미
- "SELECT B.고객명 FROM 주문 A, 고객 B WHERE A.고객번호 = B.고객번호" 쿼리에서 조인키(Join Key)는 "고객번호"

### 3. 모델이 표현하는 트랜잭션의 이해
#### 트랜잭션이란
- `데이터베이스에서 수행되는 하나의 작업 단위나 일련의 연산` 의미
- 여러 개의 개별 단계로 구성될 수있으며, 이러한 단계들은 `모두 함께 성공적으로 완료되거나, 하나라도 실패할 경우 전체 작업이 취소`되어야 함 (= 트랜잭션의 원자성)
- A와 B가 하나의 트랜잭션으로 묶여 처리된다고 할 경우, `커밋(Commit)은 A와 B를 모두 수행한 다음` 해줘야 함 (각각 커밋 x)
- ex) '은행 계좌 이체' 트랜잭션 : 
	- 은행 계좌 이체가 정상적으로 완료되기 위해서는 보낸 사람의 통장에서 보낸 금액만큼 차감하는 과정과 받는 사람의 계좌에 받은 만큼의 금액이 입금되는 과정이 모두 이루어져야 함
	- 만약 이 두 가지 과정이 정상적으로 이뤄지지 않고 보내는 사람의 계좌에서 돈을 차감한 후 받는 사람의 계좌에 돈을 입금하지 못한다면 문제가 됨
	- 트랜잭션은 이런 경우를 방지하기 위해, 모든 단계가 성공적으로 완료되거나, 하나라도 실패한다면 아무것도 적용되지 않도록 함

### 4. Null 속성의 이해
#### 널(NULL)의 특성
- 널(NULL) 값은 `아직 정의되지 않은 값, 모르는 값, 값의 부재`를 의미
- `0 또는 공백과 다름` (0은 숫자이고 공백은 하나의 문자)
- 테이블을 생성할 때 `NOT NULL` 또는 `PRIMARY KEY`로 정의되지 않은 모든 데이터 유형은 널 값 포함 가능
- 결과값을 NULL이 아닌 다른 값을 얻고자 할 때 `NVL/ISNULL 함수`를 사용
- 널 값의 대상이 숫자 유형 데이터인 경우는 주로 0(Zero)으로, 문자 유형 데이터인 경우는 공백보다는 'x' 같이 해당 시스템에서 의미 없는 문자로 바꾸는 경우가 많음

#### 널(NULL) 연산
- `NULL 값을 포함하는 연산(+,-,*,/ 등)`의 경우 `결괏값도 NULL 값` (모르는 데이터에  숫자를 더하거나 빼도 결과는 마찬가지로 모르는 데이터인 것과 같음)
- `NULL 값과의 비교연산(=,>,>=,<,<=)`은 `거짓(FALSE)을 리턴`
- `NULL = NULL` 연산의 결과는 `FALSE 또는 unknown`
- `집계 함수를 계산`할 때 `NULL 값은 계산에서 제외`됨 (NULL 값은 0으로 처리된다 x)
